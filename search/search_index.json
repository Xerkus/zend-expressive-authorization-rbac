{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-authorization-rbac\n\n\n\n\n\n\nThis library provides a zend-rbac adapter for zend-expressive-authorization.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-authorization-rbac\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "zend-expressive-authorization-rbac"
        },
        {
            "location": "/#zend-expressive-authorization-rbac",
            "text": "This library provides a zend-rbac adapter for zend-expressive-authorization.",
            "title": "zend-expressive-authorization-rbac"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-authorization-rbac",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/v1/intro/",
            "text": "RBAC Authorizations for Expressive\n\n\nThis component provides \nRole-Based Access Control\n\n(RBAC) authorization abstraction for the \nzend-expressive-authorization\n\nlibrary.\n\n\nRBAC is based on the idea of \nroles\n. In a web application, users have an\n\nidentity\n (e.g. username, email, etc). Each identified user then has one or\nmore roles (e.g. admin, editor, guest). Each role has a \npermission\n to\nperform one or more actions (e.g. access an URL, execute specific web API\ncalls).\n\n\nIn a typical RBAC system:\n\n\n\n\nAn \nidentity\n has one or more roles.\n\n\nA \nrole\n requests access to a permission.\n\n\nA \npermission\n is given to a role.\n\n\n\n\nThus, RBAC has the following model:\n\n\n\n\nMany-to-many relationship between identities and roles.\n\n\nMany-to-many relationship between roles and permissions.\n\n\nRoles can have a parent role.\n\n\n\n\nThe first requirement for an RBAC system is \nidentities\n. In our scenario, the\nusers are generated by an authentication system, provided by\n\nzend-expressive-authentication\n.\nThat library provides a PSR-7 request attribute named\n\nZend\\Expressive\\Authentication\\UserInterface\n when a user is authenticated.\nThe RBAC system uses this instance to get information about the user's identity.\n\n\nConfigure an RBAC system\n\n\nYou can configure your RBAC using a configuration file, as follows:\n\n\n// config/autoload/authorization.local.php\nreturn [\n    // ...\n    'zend-expressive-authorization-rbac' => [\n        'roles' => [\n            'administrator' => [],\n            'editor'        => ['administrator'],\n            'contributor'   => ['editor'],\n        ],\n        'permissions' => [\n            'contributor' => [\n                'admin.dashboard',\n                'admin.posts',\n            ],\n            'editor' => [\n                'admin.publish',\n            ],\n            'administrator' => [\n                'admin.settings',\n            ],\n        ],\n    ]\n];\n\n\n\nIn the above example, we designed an RBAC system with 3 roles: \nadministator\n,\n\neditor\n, and \ncontributor\n. We defined a hierarchy of roles as follows:\n\n\n\n\nadministrator\n has no parent role.\n\n\neditor\n has \nadministrator\n as a parent. That means \nadministrator\n inherits\n  the permissions of the \neditor\n.\n\n\ncontributor\n has \neditor\n as a parent. That means \neditor\n inherits the\n  permissions of \ncontributor\n, and following the chain, \nadministator\n inherits\n  the permissions of \ncontributor\n.\n\n\n\n\nFor each role, we specified an array of permissions. As you can notice, a\npermission is just a string; it can represent anything. In our implementation,\nthis string represents a route name.  That means the \ncontributor\n role can\naccess the routes \nadmin.dashboard\n and \nadmin.posts\n but cannot access the\nroutes \nadmin.publish\n (assigned to \neditor\n role) and \nadmin.settings\n\n(assigned to \nadministrator\n).\n\n\nIf you want to change the authorization logic for each permission, you can write\nyour own \nZend\\Expressive\\Authorization\\AuthorizationInterface\n implementation.\nThat interface defines the following method:\n\n\nisGranted(string $role, ServerRequestInterface $request) : bool\n\n\n\nwhere \n$role\n is the role and \n$request\n is the PSR-7 HTTP request to authorize.\n\n\n\n\nThis library uses the \nzendframework/zend-permissions-rbac\n\nlibrary to implement the RBAC system. If you want to know more about the usage\nof this library, read the blog post \n\nManage permissions with zend-permissions-rbac\n.",
            "title": "Introduction"
        },
        {
            "location": "/v1/intro/#rbac-authorizations-for-expressive",
            "text": "This component provides  Role-Based Access Control \n(RBAC) authorization abstraction for the  zend-expressive-authorization \nlibrary.  RBAC is based on the idea of  roles . In a web application, users have an identity  (e.g. username, email, etc). Each identified user then has one or\nmore roles (e.g. admin, editor, guest). Each role has a  permission  to\nperform one or more actions (e.g. access an URL, execute specific web API\ncalls).  In a typical RBAC system:   An  identity  has one or more roles.  A  role  requests access to a permission.  A  permission  is given to a role.   Thus, RBAC has the following model:   Many-to-many relationship between identities and roles.  Many-to-many relationship between roles and permissions.  Roles can have a parent role.   The first requirement for an RBAC system is  identities . In our scenario, the\nusers are generated by an authentication system, provided by zend-expressive-authentication .\nThat library provides a PSR-7 request attribute named Zend\\Expressive\\Authentication\\UserInterface  when a user is authenticated.\nThe RBAC system uses this instance to get information about the user's identity.",
            "title": "RBAC Authorizations for Expressive"
        },
        {
            "location": "/v1/intro/#configure-an-rbac-system",
            "text": "You can configure your RBAC using a configuration file, as follows:  // config/autoload/authorization.local.php\nreturn [\n    // ...\n    'zend-expressive-authorization-rbac' => [\n        'roles' => [\n            'administrator' => [],\n            'editor'        => ['administrator'],\n            'contributor'   => ['editor'],\n        ],\n        'permissions' => [\n            'contributor' => [\n                'admin.dashboard',\n                'admin.posts',\n            ],\n            'editor' => [\n                'admin.publish',\n            ],\n            'administrator' => [\n                'admin.settings',\n            ],\n        ],\n    ]\n];  In the above example, we designed an RBAC system with 3 roles:  administator , editor , and  contributor . We defined a hierarchy of roles as follows:   administrator  has no parent role.  editor  has  administrator  as a parent. That means  administrator  inherits\n  the permissions of the  editor .  contributor  has  editor  as a parent. That means  editor  inherits the\n  permissions of  contributor , and following the chain,  administator  inherits\n  the permissions of  contributor .   For each role, we specified an array of permissions. As you can notice, a\npermission is just a string; it can represent anything. In our implementation,\nthis string represents a route name.  That means the  contributor  role can\naccess the routes  admin.dashboard  and  admin.posts  but cannot access the\nroutes  admin.publish  (assigned to  editor  role) and  admin.settings \n(assigned to  administrator ).  If you want to change the authorization logic for each permission, you can write\nyour own  Zend\\Expressive\\Authorization\\AuthorizationInterface  implementation.\nThat interface defines the following method:  isGranted(string $role, ServerRequestInterface $request) : bool  where  $role  is the role and  $request  is the PSR-7 HTTP request to authorize.   This library uses the  zendframework/zend-permissions-rbac \nlibrary to implement the RBAC system. If you want to know more about the usage\nof this library, read the blog post  Manage permissions with zend-permissions-rbac .",
            "title": "Configure an RBAC system"
        },
        {
            "location": "/v1/dynamic-assertion/",
            "text": "Dynamic assertion\n\n\nIn some cases you will need to authorize a role based on a specific HTTP request.\nFor instance, imagine that you have an \"editor\" role that can add/update/delete\na page in a Content Management System (CMS). We want to prevent an \"editor\" from\nmodifying pages they have not created.\n\n\nThese types of authorization are called \ndynamic assertions\n\nand are implemented via the \nZend\\Permissions\\Rbac\\AssertionInterface\n of\n\nzend-permissions-rbac\n.\n\n\nIn order to use it, this package provides \nZendRbacAssertionInterface\n,\nwhich extends \nZend\\Permissions\\Rbac\\AssertionInterface\n:\n\n\nnamespace Zend\\Expressive\\Authorization\\Rbac;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Permissions\\Rbac\\AssertionInterface;\n\ninterface ZendRbacAssertionInterface extends AssertionInterface\n{\n    public function setRequest(ServerRequestInterface $request) : void;\n}\n\n\n\nThe \nZend\\Permissions\\Rbac\\AssertionInterface\n defines the following:\n\n\nnamespace Zend\\Permissions\\Rbac;\n\ninterface AssertionInterface\n{\n    public function assert(Rbac $rbac, RoleInterface $role, string $permission) : bool;\n}\n\n\n\nGoing back to our use case, we can build a class to manage the \"editor\"\nauthorization requirements, as follows:\n\n\nuse Zend\\Expressive\\Authorization\\Rbac\\ZendRbacAssertionInterface;\nuse App\\Service\\Article;\n\nclass EditorAuth implements ZendRbacAssertionInterface\n{\n    public function __construct(Article $article)\n    {\n        $this->article = $article;\n    }\n\n    public function setRequest(ServerRequestInterface $request)\n    {\n        $this->request = $request;\n    }\n\n    public function assert(Rbac $rbac, RoleInterface $role, string $permission)\n    {\n        $user = $this->request->getAttribute(UserInterface::class, false);\n        return $this->article->isUserOwner($user->getIdentity(), $this->request);\n    }\n}\n\n\n\nWhere \nArticle\n is a class that checks if the identified user is the owner of\nthe article referenced in the HTTP request.\n\n\nIf you manage articles using a SQL database, the implementation of\n\nisUserOwner()\n might look like the following:\n\n\npublic function isUserOwner(string $identity, ServerRequestInterface $request): bool\n{\n    // get the article {article_id} attribute specified in the route\n    $url = $request->getAttribute('article_id', false);\n    if (! $url) {\n        return false;\n    }\n    $sth = $this->pdo->prepare(\n        'SELECT * FROM article WHERE url = :url AND owner = :identity'\n    );\n    $sth->bindParam(':url', $url);\n    $sth->bindParam(':identity', $identity);\n    if (! $sth->execute()) {\n        return false;\n    }\n    $row = $sth->fetch();\n    return ! empty($row);\n}\n\n\n\nTo pass the \nArticle\n dependency to your assertion, you can use a Factory class\nthat generates the \nEditorAuth\n class instance, as follows:\n\n\nuse App\\Service\\Article;\n\nclass EditorAuthFactory\n{\n    public function __invoke(ContainerInterface $container) : EditorAuth\n    {\n        return new EditorAuth(\n            $container->get(Article::class)\n        );\n    }\n}\n\n\n\nAnd configure the service container to use \nEditorAuthFactory\n to point to\n\nEditorAuth\n, using the following configuration:\n\n\nreturn [    \n    'dependencies' => [\n        'factories' => [\n            // ...\n            EditorAuth::class => EditorAuthFactory::class\n        ]\n    ]\n];",
            "title": "Dynamic assertion"
        },
        {
            "location": "/v1/dynamic-assertion/#dynamic-assertion",
            "text": "In some cases you will need to authorize a role based on a specific HTTP request.\nFor instance, imagine that you have an \"editor\" role that can add/update/delete\na page in a Content Management System (CMS). We want to prevent an \"editor\" from\nmodifying pages they have not created.  These types of authorization are called  dynamic assertions \nand are implemented via the  Zend\\Permissions\\Rbac\\AssertionInterface  of zend-permissions-rbac .  In order to use it, this package provides  ZendRbacAssertionInterface ,\nwhich extends  Zend\\Permissions\\Rbac\\AssertionInterface :  namespace Zend\\Expressive\\Authorization\\Rbac;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Permissions\\Rbac\\AssertionInterface;\n\ninterface ZendRbacAssertionInterface extends AssertionInterface\n{\n    public function setRequest(ServerRequestInterface $request) : void;\n}  The  Zend\\Permissions\\Rbac\\AssertionInterface  defines the following:  namespace Zend\\Permissions\\Rbac;\n\ninterface AssertionInterface\n{\n    public function assert(Rbac $rbac, RoleInterface $role, string $permission) : bool;\n}  Going back to our use case, we can build a class to manage the \"editor\"\nauthorization requirements, as follows:  use Zend\\Expressive\\Authorization\\Rbac\\ZendRbacAssertionInterface;\nuse App\\Service\\Article;\n\nclass EditorAuth implements ZendRbacAssertionInterface\n{\n    public function __construct(Article $article)\n    {\n        $this->article = $article;\n    }\n\n    public function setRequest(ServerRequestInterface $request)\n    {\n        $this->request = $request;\n    }\n\n    public function assert(Rbac $rbac, RoleInterface $role, string $permission)\n    {\n        $user = $this->request->getAttribute(UserInterface::class, false);\n        return $this->article->isUserOwner($user->getIdentity(), $this->request);\n    }\n}  Where  Article  is a class that checks if the identified user is the owner of\nthe article referenced in the HTTP request.  If you manage articles using a SQL database, the implementation of isUserOwner()  might look like the following:  public function isUserOwner(string $identity, ServerRequestInterface $request): bool\n{\n    // get the article {article_id} attribute specified in the route\n    $url = $request->getAttribute('article_id', false);\n    if (! $url) {\n        return false;\n    }\n    $sth = $this->pdo->prepare(\n        'SELECT * FROM article WHERE url = :url AND owner = :identity'\n    );\n    $sth->bindParam(':url', $url);\n    $sth->bindParam(':identity', $identity);\n    if (! $sth->execute()) {\n        return false;\n    }\n    $row = $sth->fetch();\n    return ! empty($row);\n}  To pass the  Article  dependency to your assertion, you can use a Factory class\nthat generates the  EditorAuth  class instance, as follows:  use App\\Service\\Article;\n\nclass EditorAuthFactory\n{\n    public function __invoke(ContainerInterface $container) : EditorAuth\n    {\n        return new EditorAuth(\n            $container->get(Article::class)\n        );\n    }\n}  And configure the service container to use  EditorAuthFactory  to point to EditorAuth , using the following configuration:  return [    \n    'dependencies' => [\n        'factories' => [\n            // ...\n            EditorAuth::class => EditorAuthFactory::class\n        ]\n    ]\n];",
            "title": "Dynamic assertion"
        }
    ]
}